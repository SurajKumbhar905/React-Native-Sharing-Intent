"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;
var _kleur = _interopRequireDefault(require("kleur"));
var _patchCodegen = require("../utils/patchCodegen");
var _spawn = require("../utils/spawn");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _del = _interopRequireDefault(require("del"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
async function build({
  root,
  report
}) {
  const packageJsonPath = _path.default.resolve(root, 'package.json');
  const packageJson = await _fsExtra.default.readJson(packageJsonPath);
  const codegenIosPath = packageJson.codegenConfig?.outputDir?.ios;
  if (codegenIosPath != null) {
    report.info(`Cleaning up previous iOS codegen native code at ${_kleur.default.blue(_path.default.relative(root, codegenIosPath))}`);
    await (0, _del.default)([codegenIosPath]);
  }
  const codegenAndroidPath = packageJson.codegenConfig?.outputDir?.android;
  if (codegenAndroidPath != null) {
    report.info(`Cleaning up previous Android codegen native code at ${_kleur.default.blue(_path.default.relative(root, codegenAndroidPath))}`);
    await (0, _del.default)([codegenAndroidPath]);
  }
  try {
    await (0, _spawn.spawn)('npx', ['react-native', 'codegen'], {
      stdio: 'ignore'
    });
    (0, _patchCodegen.patchCodegen)(root, packageJson, report);
    report.success('Generated native code with codegen');
  } catch (e) {
    if (e != null && typeof e === 'object') {
      if ('stdout' in e && e.stdout != null) {
        report.error(`Errors found while generating codegen files:\n${e.stdout.toString()}`);
      } else if ('message' in e && typeof e.message === 'string') {
        report.error(e.message);
      } else {
        throw e;
      }
    } else {
      throw e;
    }
    throw new Error('Failed generate the codegen files.');
  }
}
//# sourceMappingURL=codegen.js.map